# This pipeline:
# 1) Builds/publishes an unsigned .NET executable
# 2) Optionally loads signing inputs from Azure Key Vault
# 3) Ensures the Trusted Signing certificate profile exists (creates it if needed)
# 4) Signs the binary with SignTool + Artifact Signing dlib
# 5) Verifies and publishes the signed artifact

trigger:
- main

pool:
  vmImage: 'windows-latest'

variables:
  # Build settings for the demo app.
  buildConfiguration: 'Release'
  runtimeIdentifier: 'win-x64'

  # AzureRM service connection name in Azure DevOps.
  # Terraform defaults this to 'sc-artifact-signing'.
  azureServiceConnection: 'sc-artifact-signing'

  # Key Vault integration:
  # - If keyVaultName is non-empty, AzureKeyVault@2 will pull the secrets below
  #   and populate the corresponding pipeline variables at runtime.
  # - If keyVaultName is empty, you must set the artifactSigning* variables
  #   via pipeline variables or a variable group.
  keyVaultName: ''

  # Trusted Signing inputs (usually sourced from Key Vault):
  artifactSigningEndpoint: ''
  artifactSigningAccountName: ''
  artifactSigningCertificateProfileName: ''

  # Identity validation is portal-only; when the profile does not exist yet,
  # set this (preferably as a Key Vault secret) so the pipeline can create it.
  artifactSigningIdentityValidationId: ''

  # Resource group that contains the Code Signing account.
  artifactSigningResourceGroupName: ''

  # Certificate profile type to create if missing.
  # This must match the Microsoft.CodeSigning API allowed values.
  artifactSigningCertificateProfileType: 'PublicTrust'

  # Optional: object id of the Azure DevOps service principal.
  # If provided, the pipeline will attempt to ensure the signer RBAC role assignment.
  # (Terraform can also handle RBAC; this is a best-effort helper.)
  adoServicePrincipalObjectId: ''

steps:
# Build the demo app, producing an unsigned SigningDemo.exe.
- task: DotNetCoreCLI@2
  displayName: Publish (unsigned)
  inputs:
    command: publish
    projects: '**/SigningDemo.csproj'
    arguments: '-c $(buildConfiguration) -r $(runtimeIdentifier) --self-contained false'

# Load signing inputs from Key Vault (only if keyVaultName is set).
- task: AzureKeyVault@2
  displayName: Load signing variables from Key Vault
  condition: and(succeeded(), ne(variables['keyVaultName'], ''))
  inputs:
    azureSubscription: '$(azureServiceConnection)'
    KeyVaultName: '$(keyVaultName)'
    SecretsFilter: 'artifactSigningEndpoint,artifactSigningAccountName,artifactSigningCertificateProfileName,artifactSigningIdentityValidationId'
    RunAsPreJob: false

# Sign the binary.
# Notes:
# - If the certificate profile doesn't exist yet, this step creates it via ARM (az rest).
# - To create the profile, the service connection identity typically needs permission at RG/account scope.
# - To sign, the identity needs the appropriate Artifact Signing signer role.
- task: AzureCLI@2
  displayName: Sign with Azure Artifact Signing (SignTool + dlib)
  inputs:
    azureSubscription: '$(azureServiceConnection)'
    scriptType: ps
    scriptLocation: inlineScript
    inlineScript: |
      $ErrorActionPreference = 'Stop'

      function Get-Trimmed([string]$value) {
        if ($null -eq $value) { return '' }
        return $value.Trim()
      }

      $rg = Get-Trimmed "$(artifactSigningResourceGroupName)"
      if ([string]::IsNullOrWhiteSpace($rg)) { throw "Missing variable: artifactSigningResourceGroupName" }

      $accountName = Get-Trimmed "$(artifactSigningAccountName)"
      $profileName = Get-Trimmed "$(artifactSigningCertificateProfileName)"
      $profileType = Get-Trimmed "$(artifactSigningCertificateProfileType)"
      if ([string]::IsNullOrWhiteSpace($profileType)) { $profileType = 'PublicTrust' }

      if ([string]::IsNullOrWhiteSpace("$(artifactSigningEndpoint)")) { throw "Missing variable: artifactSigningEndpoint" }
      if ([string]::IsNullOrWhiteSpace($accountName)) { throw "Missing variable: artifactSigningAccountName" }
      if ([string]::IsNullOrWhiteSpace($profileName)) { throw "Missing variable: artifactSigningCertificateProfileName" }

      $identityValidationId = Get-Trimmed "$(artifactSigningIdentityValidationId)"

      $subId = (az account show --query id -o tsv)
      if ([string]::IsNullOrWhiteSpace($subId)) { throw "Unable to determine subscription id from AzureCLI context." }

      $profileResourceId = "/subscriptions/$subId/resourceGroups/$rg/providers/Microsoft.CodeSigning/codeSigningAccounts/$accountName/certificateProfiles/$profileName"
      $profileUrl = "https://management.azure.com$profileResourceId?api-version=2025-10-13"

      # If the profile doesn't exist yet (first run), create it using the identity validation ID.
      Write-Host "Ensuring certificate profile exists: $profileResourceId"

      $profileExists = $false
      try {
        az rest --method get --url $profileUrl --only-show-errors | Out-Null
        $profileExists = $true
      } catch {
        $profileExists = $false
      }

      if (-not $profileExists) {
        if ([string]::IsNullOrWhiteSpace($identityValidationId)) {
          throw "Certificate profile is missing. Complete identity validation in the portal and set Key Vault secret 'artifactSigningIdentityValidationId' (or set pipeline variable artifactSigningIdentityValidationId)."
        }

        $body = @{
          properties = @{
            identityValidationId   = $identityValidationId
            profileType           = $profileType
            includeStreetAddress  = $false
            includePostalCode     = $false
          }
        } | ConvertTo-Json -Depth 10

        az rest --method put --url $profileUrl --body $body --only-show-errors | Out-Null
        Write-Host "Created certificate profile: $profileName"
      }

      # Optional best-effort RBAC helper: assign signer role at the profile scope.
      # If Terraform already assigned roles, this is usually unnecessary.
      $spObjectId = Get-Trimmed "$(adoServicePrincipalObjectId)"
      if (-not [string]::IsNullOrWhiteSpace($spObjectId)) {
        $roleName = "Artifact Signing Certificate Profile Signer"
        Write-Host "Ensuring RBAC role '$roleName' on profile for SP object id $spObjectId"
        try {
          az role assignment create --assignee-object-id $spObjectId --assignee-principal-type ServicePrincipal --role $roleName --scope $profileResourceId --only-show-errors | Out-Null
        } catch {
          Write-Host "Role assignment may already exist; continuing."
        }
      }

      az account show --output table

      # Download tooling via NuGet extraction:
      # - nuget.exe (for pulling packages)
      # - Microsoft.Windows.SDK.BuildTools (signtool.exe)
      # - Microsoft.ArtifactSigning.Client (Azure.CodeSigning.Dlib.dll)
      $tempRoot = Join-Path "$(Agent.TempDirectory)" "artifact-signing"
      New-Item -ItemType Directory -Force -Path $tempRoot | Out-Null

      $nugetExe = Join-Path $tempRoot "nuget.exe"
      Invoke-WebRequest -Uri https://dist.nuget.org/win-x86-commandline/latest/nuget.exe -OutFile $nugetExe

      $sdkOut = Join-Path $tempRoot "sdk"
      & $nugetExe install Microsoft.Windows.SDK.BuildTools -x -OutputDirectory $sdkOut | Out-Host

      $signtool = Get-ChildItem -Path $sdkOut -Recurse -Filter signtool.exe | Where-Object { $_.FullName -match "\\x64\\signtool\\.exe$" } | Select-Object -First 1
      if (-not $signtool) {
        $signtool = Get-ChildItem -Path $sdkOut -Recurse -Filter signtool.exe | Where-Object { $_.FullName -match "\\x64\\signtool\\.exe" } | Select-Object -First 1
      }
      if (-not $signtool) { throw "signtool.exe not found after extracting Microsoft.Windows.SDK.BuildTools" }

      $dlibOut = Join-Path $tempRoot "dlib"
      & $nugetExe install Microsoft.ArtifactSigning.Client -x -OutputDirectory $dlibOut | Out-Host

      $dlib = Get-ChildItem -Path $dlibOut -Recurse -Filter Azure.CodeSigning.Dlib.dll | Where-Object { $_.FullName -match "\\x64\\Azure\\.CodeSigning\\.Dlib\\.dll$" } | Select-Object -First 1
      if (-not $dlib) {
        $dlib = Get-ChildItem -Path $dlibOut -Recurse -Filter Azure.CodeSigning.Dlib.dll | Select-Object -First 1
      }
      if (-not $dlib) { throw "Azure.CodeSigning.Dlib.dll not found after extracting Microsoft.ArtifactSigning.Client" }

      $metadataPath = Join-Path $tempRoot "metadata.json"
      # metadata.json is consumed by the dlib and tells it which account/profile to use.
      $metadata = @{
        Endpoint               = "$(artifactSigningEndpoint)"
        CodeSigningAccountName = "$(artifactSigningAccountName)"
        CertificateProfileName = "$(artifactSigningCertificateProfileName)"
        CorrelationId          = "build-$(Build.BuildId)"
      } | ConvertTo-Json -Depth 4

      $metadata | Out-File -FilePath $metadataPath -Encoding utf8

      $unsigned = "$(Build.SourcesDirectory)\SigningDemo\bin\$(buildConfiguration)\net8.0\$(runtimeIdentifier)\publish\SigningDemo.exe"
      if (-not (Test-Path $unsigned)) { throw "Unsigned binary not found at $unsigned" }

      $signedDir = "$(Build.ArtifactStagingDirectory)"
      New-Item -ItemType Directory -Force -Path $signedDir | Out-Null
      $signed = Join-Path $signedDir "SigningDemo.signed.exe"
      Copy-Item $unsigned $signed -Force

      Write-Host "Using signtool: $($signtool.FullName)"
      Write-Host "Using dlib: $($dlib.FullName)"

      # Sign in-place using the official SignTool + /dlib flow.
      & $signtool.FullName sign /v /debug /fd SHA256 /tr "http://timestamp.acs.microsoft.com" /td SHA256 /dlib "$($dlib.FullName)" /dmdf "$metadataPath" "$signed"

# Verify that Windows considers the resulting file authenticode-signed.
- powershell: |
    $ErrorActionPreference = 'Stop'
    $signed = "$(Build.ArtifactStagingDirectory)\SigningDemo.signed.exe"
    Get-AuthenticodeSignature $signed | Format-List
  displayName: Verify signature

# Publish the signed binary as a build artifact.
- task: PublishBuildArtifacts@1
  displayName: Publish signed artifact
  inputs:
    pathToPublish: '$(Build.ArtifactStagingDirectory)'
    artifactName: 'signed-drop'
